package org.broadinstitute.hellbender.tools.exome;

import htsjdk.samtools.metrics.MetricsFile;
import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.variantcontext.writer.VariantContextWriter;
import org.apache.commons.lang3.tuple.Pair;
import org.broadinstitute.hellbender.cmdline.Argument;
import org.broadinstitute.hellbender.cmdline.CommandLineProgramProperties;
import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;
import org.broadinstitute.hellbender.cmdline.programgroups.VariantProgramGroup;
import org.broadinstitute.hellbender.engine.FeatureContext;
import org.broadinstitute.hellbender.engine.ReadsContext;
import org.broadinstitute.hellbender.engine.ReferenceContext;
import org.broadinstitute.hellbender.engine.VariantWalker;
import org.broadinstitute.hellbender.exceptions.UserException;
import org.broadinstitute.hellbender.tools.exome.orientationbiasvariantfilter.ArtifactMode;
import org.broadinstitute.hellbender.tools.exome.orientationbiasvariantfilter.OrientationBiasFilterer;
import org.broadinstitute.hellbender.tools.exome.orientationbiasvariantfilter.OrientationBiasUtils;
import org.broadinstitute.hellbender.tools.exome.orientationbiasvariantfilter.PreAdapterOrientationScorer;
import org.broadinstitute.hellbender.tools.picard.analysis.artifacts.SequencingArtifactMetrics;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.*;



@CommandLineProgramProperties(
        summary = "Filter M2 Somatic VCFs using the Orientation Bias Filter.\n" +
                "Used for the OxoG (G/T) and Deamination (FFPE) (C/T) artifacts that get introduced into our SNV calling.\n" +
                "\n" +
                "Notes:  All variants are held in RAM.\n This tool will only catch artifacts in diploid organisms.  Others will cause an error.\n" +
                "Triallelic sites may not be considered for filtering -- the behavior of this tool is undefined for triallelic sites.\n" +
                "This tool was tested only with output for GATK4 MuTect and makes assumptions about the existence of fields produced by GATK4 MuTect.\n" +
                "ALT_F1R2 and ALT_F2R1 tags must be present in all SNP variants.\n" +
                "Do NOT specify artifact modes that are complements of each other.  Behavior of this tool is undefined when that happens.\n" +
                "Any variants that are filtered in the input file are not considered for filtering here, nor are these variants used in deciding cutoff.\n" +
                "Common artifacts:\n G/T (OxoG)\n C/T (deamination) ",
        oneLineSummary = "Filter M2 Somatic VCFs using the Orientation Bias Filter.",
        programGroup = VariantProgramGroup.class
)
public class FilterByOrientationBias extends VariantWalker {

    public static final String PRE_ADAPTER_METRICS_DETAIL_FILE_SHORT_NAME = "P";
    public static final String PRE_ADAPTER_METRICS_DETAIL_FILE_FULL_NAME = "preAdapterDetailFile";
    public static final String ARTIFACT_MODES_SHORT_NAME = "A";
    public static final String ARTIFACT_MODES_FULL_NAME = "artifactModes";

    public static final String DEFAULT_ARTIFACT_MODE = "G/T";

    @Argument(
            doc="Output Somatic SNP/Indel VCF file",
            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,
            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,
            optional = false)
    protected File outputFile;

    @Argument(
            doc = "PreAdapter Detail metrics file.  Usually, generated by CollectSequencingArtifactMetrics.",
            shortName = PRE_ADAPTER_METRICS_DETAIL_FILE_SHORT_NAME,
            fullName = PRE_ADAPTER_METRICS_DETAIL_FILE_FULL_NAME,
            optional = false)
    protected File preAdapterMetricsFile;

    @Argument(
            doc = "PreAdapter Detail artifacts of interest on the forward strand.  'C/A' for a single artifact.  Separated by commas to assume multiple artifacts at the same time:  'C/A,T/G'  Artifacts must be one base to one base (e.g. 'CC/CA' is illegal).  G>T is OxoG.",
            shortName = ARTIFACT_MODES_SHORT_NAME,
            fullName = ARTIFACT_MODES_FULL_NAME,
            optional = true
    )
    protected List<String> artifactModes = new ArrayList<>();

    private Map<ArtifactMode, Double> artifactModeToPreAdapterScoreMap;

    private SortedSet<ArtifactMode> relevantArtifactModes;

    private VariantContextWriter vcfWriter;

    /** Each has an OxoQ annotation */
    private List<VariantContext> firstPassVariants;

    @Override
    public void onTraversalStart() {

        // Gets around issue 2274 in gatk public
        if (artifactModes.size() == 0) {
            artifactModes.add(DEFAULT_ARTIFACT_MODE);
        }

        // Sort the input artifacts argument
        artifactModes.sort(null);

        final MetricsFile<SequencingArtifactMetrics.PreAdapterDetailMetrics, Comparable<?>> mf = new MetricsFile<>();

        try {
            mf.read(new FileReader(preAdapterMetricsFile));
        } catch (final FileNotFoundException fnfe) {
            throw new UserException("Could not find file: " + preAdapterMetricsFile.getAbsolutePath());
        }

        firstPassVariants = new ArrayList<>();


        // Parse the desired artifact modes from the input string.
        relevantArtifactModes  = new TreeSet<>();
        for (String artifactMode: artifactModes) {
            final String[] splitArtifactMode = artifactMode.split("/");

            if (!isValidArtifactMode(splitArtifactMode)) {
                throw new UserException("Invalid artifact mode: " + String.join("/", splitArtifactMode));
            }

            relevantArtifactModes.add(ArtifactMode.of(splitArtifactMode[0].charAt(0), splitArtifactMode[1].charAt(0)));
        }

        // Get the PreAdapterQ score, which gives an indication of how badly infested the file is.
        artifactModeToPreAdapterScoreMap = PreAdapterOrientationScorer.scoreOrientationBiasMetricsOverContext(mf.getMetrics());
        logger.info("preAdapter scores:");
        artifactModeToPreAdapterScoreMap.keySet().stream().forEach(k -> logger.info(k + ": " + artifactModeToPreAdapterScoreMap.get(k)));

        setupVCFWriter();
    }

    private boolean isValidArtifactMode(final String[] splitArtifactMode) {
        if (splitArtifactMode[0].length() != 1) {
            throw new UserException.BadInput("First base invalid - must be of length 1: " + splitArtifactMode[0]+ ". Artifact modes must be specified as one base-slash-one base.  E.g. G/T");
        } else if (splitArtifactMode[1].length() != 1) {
            throw new UserException.BadInput("Second base invalid - must be of length 1: " + splitArtifactMode[1]+ ". Artifact modes must be specified as one base-slash-one base.  E.g. G/T");
        }
        return true;
    }

    /**
     *  Just adds the Pre Adapter Q annotation to the variant and creates a new variant.
     *
     *  Note: the writing of the VCF is not done here, since we need to aggregate once we have OxoQ scores.
     *  Note:  No variant is dropped, if no additional annotation was needed, then the original format field is
     *   preserved
     * @param variant See {@link VariantWalker}
     * @param readsContext See {@link VariantWalker}
     * @param referenceContext See {@link VariantWalker}
     * @param featureContext See {@link VariantWalker}
     */
    @Override
    public void apply(VariantContext variant, ReadsContext readsContext, ReferenceContext referenceContext, FeatureContext featureContext) {
        final VariantContext updatedVariant = OrientationBiasFilterer.annotateVariantContextWithPreprocessingValues(variant, relevantArtifactModes, artifactModeToPreAdapterScoreMap);
        firstPassVariants.add(updatedVariant);

        // See onTraversalSuccess for the actual filtering.
    }

    private void setupVCFWriter() {
        vcfWriter = createVCFWriter(outputFile);
        vcfWriter.writeHeader(OrientationBiasFilterer.createVCFHeader(getHeaderForVariants(), getCommandLine(),
                artifactModes));
    }


    @Override
    public Object onTraversalSuccess() {

        logger.info("Tagging whether genotypes are in one of the artifact modes.");

        // Calculate how many artifacts need to be cut
        double fdrThresh = 0.01;

        final List<VariantContext> finalVariants = OrientationBiasFilterer.annotateVariantContextsWithFilterResults(fdrThresh, relevantArtifactModes, firstPassVariants, artifactModeToPreAdapterScoreMap);

        logger.info("Writing variants to VCF...");
        for (final VariantContext vc: finalVariants) {
            vcfWriter.add(vc);
        }
        logger.info("Writing a simple summary table...");
        final List<String> sampleNames = finalVariants.get(0).getSampleNamesOrderedByName();
        final List<Pair<String, ArtifactMode>> sampleArtifactModeCombinations =  new ArrayList<>();
        for (ArtifactMode relevantArtifactMode : relevantArtifactModes) {
            for (String sampleName : sampleNames) {
                sampleArtifactModeCombinations.add(Pair.of(sampleName, relevantArtifactMode));
            }
        }

        OrientationBiasUtils.writeOrientationBiasSummaryTable(sampleArtifactModeCombinations, finalVariants, artifactModeToPreAdapterScoreMap, new File(outputFile.getAbsolutePath() + ".summary"));
        return null;
    }

    @Override
    public void closeTool() {
        if ( vcfWriter != null) {
            vcfWriter.close();
        }
    }
}
